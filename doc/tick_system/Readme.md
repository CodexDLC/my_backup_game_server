Сервер игры: Обработка тиков и API авто-сессий

Обзор

Этот проект представляет серверную логику для управления авто-сессиями и обработки тиков персонажей в игровом окружении. Система предназначена для периодической обработки событий персонажей (тиков) с использованием базы данных и очередей Redis.

Основные компоненты:

Авто-сессии и авто-тики:Система инициирует авто-сессию для персонажа, если она не активна. В процессе запуска проверяется наличие персонажа, его сессии и создаётся новая запись в базе данных с временными метками (например, last_tick_at и next_tick_at с интервалом 6 минут).

Очереди Redis для обработки тиков:Персонажи распределяются по категориям (исследование, ремесло, торговля, общая) и помещаются в соответствующие очереди Redis. Функция process_redis_queue(db: AsyncSession) постоянно обходит эти очереди, забирая пакеты персонажей (с фиксированным размером пакета) и передавая их на обработку.

Обработчики тиков:Логика обработки тиков разделена по категориям и реализована в файле game_server/Logic/DomainLogic/TickLogic/tick_handler.py. Каждый обработчик (например, handle_exploration_tick, handle_crafting_tick, handle_trade_tick, handle_general_tick) на данном этапе содержит заглушку, которая логгирует выполнение и возвращает сообщение о завершении обработки.

Делегирование доступа к базе данных:Весь процесс работы реализован с использованием асинхронных сессий SQLAlchemy. Экземпляр db (тип AsyncSession) создаётся один раз в auto_tick и передаётся через цепочку (включая process_redis_queue и обработчики), что обеспечивает централизованное управление транзакциями и доступом к базе данных.

API для управления авто-сессиями:FastAPI используется для предоставления REST-эндпоинтов:

POST /system/tick/auto-session/start: Запускает авто-сессию для персонажа. Принимает входные данные с валидацией категории (через Pydantic-модель и Enum).

DELETE /system/tick/auto-session/delete: Удаляет активную авто-сессию для персонажа.

GET /system/tick/auto-session/status: Запрашивает статус авто-сессии.

Docker и Docker Compose:Проект контейнеризован. Чтобы собрать образ без использования кэша, можно использовать:

docker-compose build --no-cache

Это гарантирует, что все слои будут пересобраны с нуля.

Авто-сессия

При запуске авто-сессии проверяется наличие персонажа и активной сессии. Если сессия отсутствует, создаётся новая с установленными временными метками:

next_tick_at — следующий тик через 6 минут.

last_tick_at — время последнего тика.

Обработка очередей тиков

Функция process_redis_queue(db: AsyncSession) циклически обходит очереди по категориям. Для каждого пакета персонажей вызывается функция process_category_tick(category, characters, db), которая с использованием конструкции match-case направляет обработку в соответствующий обработчик из tick_handler.py.

Обработчики тиков

Файл tick_handler.py содержит заглушки для тестирования:

handle_exploration_tick

handle_crafting_tick

handle_trade_tick

handle_general_tick

Каждый из них логгирует завершение обработки и возвращает сообщение, позволяя проверить корректность цепочки вызовов до реализации полной бизнес-логики.

API-запрос

Пример запроса для запуска авто-сессии:

{
  "player_id": 123,
  "active_category": "exploration"
}

Валидация осуществляется через Pydantic-модель TickRequest, где active_category ограничен типом Enum (исследование, ремесло, торговля, общая).

Сборка Docker

Чтобы собрать образ без использования кэшированных слоёв, выполните:

  docker-compose build --no-cache

После этого можно запустить контейнеры:

Этот проект демонстрирует подход к асинхронной обработке игровых событий с использованием современных инструментов:

FastAPI для REST API,

SQLAlchemy для взаимодействия с базой данных,

Redis для реализации очередей,

Docker для контейнеризации проекта.

Система построена с учётом масштабируемости и централизованного управления транзакциями, передавая единственный экземпляр базы данных через всю цепочку обработки от запуска авто-сессии до выполнения тиков.