# Директория game_services

Эта директория является корневой для всех автономных микросервисов-воркеров проекта. Каждый сервис здесь спроектирован для запуска в отдельном Docker-контейнере и выполняет строго определенную бизнес-функцию.

Архитектура
Структура game_services основана на четком разделении ответственности:

Точки входа (..._main.py): В корне директории находятся исполнительные файлы, такие как auth_service_main.py, system_services_main.py. Каждый из этих файлов является главной точкой входа (entrypoint) для своего Docker-контейнера. Их задача — инициализировать все необходимые зависимости (подключения к БД, кэшу) и запустить соответствующий слушатель сообщений из command_center.

Инфраструктура слушателей (command_center): Вложенная папка command_center содержит всю обвязку для асинхронной обработки сообщений из RabbitMQ. Она предоставляет стандартизированный способ создания слушателей для сервисов, определенных в ..._main.py.

Поддиректория command_center
Здесь находится переиспользуемый код для создания микросервисов-потребителей. Философия этого компонента — позволить разработчикам быстро создавать новые сервисы, фокусируясь исключительно на бизнес-логике, а не на деталях работы с RabbitMQ.

Структура command_center

1. base_microservice_listener.py
Это фундамент всей системы. Абстрактный базовый класс, от которого должны наследоваться все слушатели. Он предоставляет:

Управление жизненным циклом (start/stop).

Гарантированную обработку ack/nack для сообщений RabbitMQ.

Ограничение параллелизма (MAX_CONCURRENT_TASKS).

Контроль времени выполнения (COMMAND_PROCESSING_TIMEOUT).

Единый абстрактный метод _process_single_command для реализации в дочерних классах.

1. Папки конкретных сервисов (auth_service_command, coordinator_command и т.д.)
Каждая такая папка содержит конфигурацию (..._config.py) и реализацию (..._listener.py) слушателя, который запускается из соответствующего ..._main.py в корневой директории game_services.

..._config.py: Файл конфигурации. Единственное место, где регистрируются новые команды. Он связывает строковое имя команды с ее DTO (для валидации) и классом-Handler'ом (для выполнения логики). Также здесь определяются имя очереди и политики обработки.

..._listener.py: Класс-слушатель, унаследованный от BaseMicroserviceListener. Его единственная задача — реализовать метод,_process_single_command, в котором происходит валидация payload в соответствующий DTO и передача этого DTO в Оркестратор.

..._rpc_handler.py (Опционально): Если сервису требуется предоставлять синхронные RPC-вызовы (например, для быстрой валидации токена), здесь размещается соответствующий обработчик.

Процесс создания нового сервиса
Для добавления нового микросервиса-воркера необходимо следовать шагам, описанным в главном документе: "Регламент: Создание Микросервиса-Потребителя".

Процесс включает в себя:

Определение новой очереди в rabbitmq_topology.py.

Создание новой папки в command_center со своей парой файлов config.py и listener.py.

Создание ..._main.py в корне game_services, который будет инициализировать и запускать новый слушатель.

Реализация бизнес-логики в соответствующем Оркестраторе и Обработчиках (Handlers).
