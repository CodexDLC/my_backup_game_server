# game_server/Logic/ApplicationLogic

Эта папка содержит основной слой синхронной бизнес-логики приложения. Он служит точкой входа для выполнения операций, инициированных пользователем (например, через API-запросы), и структурирован как набор потенциальных микросервисов.

Архитектура и Принципы
Сервис-ориентированная Архитектура: Слой разделен на доменные сервисы (например, UserManagementService, InventoryService), каждый из которых отвечает за свою область бизнес-логики.

Синхронный Фасад: ApplicationLogic является синхронным "фасадом" для всей бизнес-логики. Он принимает запросы, выполняет быстрые операции и возвращает немедленный ответ.

Делегирование Тяжелых Задач: Одной из ключевых обязанностей этого слоя является определение того, какие задачи должны быть выполнены немедленно, а какие — делегированы для фоновой обработки слою DomainLogic путем отправки сообщения в шину.

Взаимодействие со слоем InfrastructureLogic
Для выполнения операций с данными и кэшем сервисы из ApplicationLogic полностью полагаются на слой InfrastructureLogic. Это взаимодействие строится на следующих ключевых принципах:

Единая Точка Доступа: Все запросы к базам данных (PostgreSQL, Redis) проходят через централизованные менеджеры репозиториев (например, repository_manager), которые предоставляет InfrastructureLogic. Это скрывает детали реализации и упрощает доступ к данным.

Абстракция через Интерфейсы: ApplicationLogic работает с абстрактными интерфейсами репозиториев и менеджеров кэша, а не с их конкретными реализациями. Это обеспечивает слабую связанность и упрощает тестирование, позволяя подменять реальные реализации на "моки".

Внедрение Зависимостей (Dependency Injection): Необходимые менеджеры и репозитории из InfrastructureLogic передаются в конструкторы сервисов ApplicationLogic, а не создаются внутри них.

Двухэтапный Жизненный Цикл Сервисов
Разработка сервисов в ApplicationLogic следует гибкой двухэтапной модели:

Этап 1: Внутрипроцессная разработка (Режим "Монолита")

Описание: На начальном этапе сервис существует как обычный Python-модуль внутри основного приложения. Его методы вызываются напрямую из вышестоящего слоя (например, из API-роутов).

Цель: Максимальная скорость разработки и простота отладки на этапе формирования логики.

Этап 2: Выделение в изолированный микросервис (Режим "Контейнера")

Описание: Когда логика сервиса стабилизирована, он упаковывается в собственный Docker-контейнер. Он больше не принимает прямые вызовы, а взаимодействует с остальной системой исключительно через шину сообщений, слушая предназначенные ему команды.

Цель: Независимое развертывание, масштабирование и отказоустойчивость для зрелого сервиса.
