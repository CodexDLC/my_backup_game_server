# game_server/Logic/ApplicationLogic/coordinator_generator/template_generator_item/item_template_planner_logic.py

import json
import asyncio
import re
import time 
from typing import Dict, Any, Optional, List, Set, Tuple, Callable
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

# –ò–º–ø–æ—Ä—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω—ã –¥–ª—è –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–Ω–æ–π –ª–æ–≥–∏–∫–∏
from game_server.Logic.ApplicationLogic.coordinator_generator.utils.generator_utils import generate_item_code
from game_server.Logic.InfrastructureLogic.DataAccessLogic.manager.generators.ORM_equipment_templates import EquipmentTemplateRepository

# üî• –ò–ó–ú–ï–ù–ï–ù–ò–ï: –¢–µ–ø–µ—Ä—å –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–∞—à –≥–æ—Ç–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä-–æ–¥–∏–Ω–æ—á–∫—É, –∞ –Ω–µ –∫–ª–∞—Å—Å
from game_server.Logic.InfrastructureLogic.app_cache.services.reference_data_reader import reference_data_reader
# ÔøΩ –ò–ó–ú–ï–ù–ï–ù–ò–ï: –≠—Ç–æ—Ç –∏–º–ø–æ—Ä—Ç –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–µ–Ω
# from game_server.Logic.InfrastructureLogic.app_cache.central_redis_client import CentralRedisClient
from game_server.services.logging.logging_setup import logger

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –¥–ª—è —É—Ä–æ–≤–Ω—è —Ä–µ–¥–∫–æ—Å—Ç–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é/–Ω–µ —Ä–∞—Ä–Ω–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞
DEFAULT_RARITY_LEVEL = 9 

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –¥–ª—è –ø—Ä–∞–≤–∏–ª —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Ç–∏–ø–æ–≤ –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –∏ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤
MATERIAL_COMPATIBILITY_RULES = {
    "WEAPON": {
        "allowed_types": ["METAL", "WOOD", "BONE"],
        "disallowed_types": ["FABRIC", "LEATHER"]
    },
    "ARMOR": {
        "allowed_types": ["METAL", "LEATHER"], 
        "disallowed_types": ["FABRIC"]
    },
    "APPAREL": {
        "allowed_types": ["FABRIC", "LEATHER", "FUR"], 
        "disallowed_types": ["METAL"] 
    },
    "ACCESSORY": {
        "allowed_types": ["METAL", "FABRIC", "LEATHER", "GEM", "BONE", "WOOD"],
        "disallowed_types": [] 
    },
    "UNKNOWN_CATEGORY": { 
        "allowed_types": [], 
        "disallowed_types": ["METAL", "FABRIC", "LEATHER"] 
    }
}

class ItemTemplatePlannerLogic:
    # üî• –ò–ó–ú–ï–ù–ï–ù–ò–ï: –£–±–∏—Ä–∞–µ–º redis_client –∏–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤, –æ–Ω –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–µ–Ω
    def __init__(
        self,
        async_session_factory: Callable[[], AsyncSession],
        item_generation_limit: Optional[int] = None
    ):
        self.async_session_factory = async_session_factory
        self.item_generation_limit = item_generation_limit
        # üî• –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—à –≥–æ—Ç–æ–≤—ã–π –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Ä–∏–¥–µ—Ä–∞.
        # –ë–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –µ–≥–æ –∑–¥–µ—Å—å.
        self._reference_data_reader = reference_data_reader


    async def load_reference_data_from_redis(self) -> tuple[Dict, Dict, Dict, Dict]:
        """–ó–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö —Å–ø—Ä–∞–≤–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ –º–µ–Ω–µ–¥–∂–µ—Ä."""
        logger.debug("ItemTemplatePlannerLogic: –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø—Ä–∞–≤–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏–∑ Redis...")

        item_base = await self._reference_data_reader.get_all_item_bases()
        materials = await self._reference_data_reader.get_all_materials()
        suffixes = await self._reference_data_reader.get_all_suffixes()
        modifiers = await self._reference_data_reader.get_all_modifiers()

        logger.debug(f"ItemTemplatePlannerLogic: –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(item_base)} item_base, {len(materials)} –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤, {len(suffixes)} —Å—É—Ñ—Ñ–∏–∫—Å–æ–≤, {len(modifiers)} –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤.")
        return item_base, materials, suffixes, modifiers

    async def get_existing_item_codes_from_db(self) -> Set[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö item_code –∏–∑ –ë–î."""
        async with self.async_session_factory() as session:
            repo = EquipmentTemplateRepository(session)
            existing_codes = await repo.get_all_item_codes()
            logger.debug(f"ItemTemplatePlannerLogic: –ü–æ–ª—É—á–µ–Ω–æ {len(existing_codes)} —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö item_code –∏–∑ –ë–î.")
            return set(existing_codes)

    def build_etalon_item_codes(
        self, item_base_data: Dict[str, Any], materials_data: Dict[str, Any], suffixes_data: Dict[str, Any]
    ) -> Dict[str, Tuple]:
        """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ –ø—É–ª–∞ item_code –∏ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö."""
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª–æ–≤–∞—Ä—å, —á—Ç–æ–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å –ø–æ item_code
        etalon_item_data_specs: Dict[str, Tuple] = {}
        logger.info("ItemTemplatePlannerLogic: –ù–∞—á–∞–ª–æ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ –ø—É–ª–∞ item_code.")
        
        start_time = time.time()

        if not item_base_data or not materials_data or not suffixes_data:
            logger.warning("build_etalon_item_codes: –û–¥–∏–Ω –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –Ω–∞–±–æ—Ä–æ–≤ —Å–ø—Ä–∞–≤–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø—É—Å—Ç—ã. –≠—Ç–∞–ª–æ–Ω–Ω—ã–π –ø—É–ª –Ω–µ –±—É–¥–µ—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω.")
            return etalon_item_data_specs

        base_codes_processed = 0
        specific_names_processed = 0
        material_codes_processed = 0
        suffix_codes_processed = 0
        
        for base_code, base_info in item_base_data.items():
            base_codes_processed += 1
            category = base_info.get('category', 'UNKNOWN_CATEGORY') 
            specific_names_map = base_info.get('names', {})
            
            if not specific_names_map:
                logger.warning(f"build_etalon_item_codes: item_base '{base_code}' –Ω–µ –∏–º–µ–µ—Ç 'names' –∏–ª–∏ –æ–Ω–∏ –ø—É—Å—Ç—ã. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º.")
                continue

            for original_specific_name, name_properties in specific_names_map.items():
                specific_names_processed += 1
                allowed_suffix_groups = set(name_properties.get('allowed_suffix_groups', []))
                
                if not allowed_suffix_groups and "BASIC_EMPTY" not in suffixes_data:
                    logger.warning(f"build_etalon_item_codes: specific_name '{original_specific_name}' –¥–ª—è base '{base_code}' –Ω–µ –∏–º–µ–µ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö –≥—Ä—É–ø–ø —Å—É—Ñ—Ñ–∏–∫—Å–æ–≤, –∏ BASIC_EMPTY –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —ç—Ç—É –≤–µ—Ç–∫—É.")

                for material_code, material_info in materials_data.items():
                    material_codes_processed += 1
                    
                    material_rarity_level = material_info.get('rarity_level') 

                    if material_rarity_level is None:
                        rarity_level_to_use = DEFAULT_RARITY_LEVEL
                        logger.debug(f"build_etalon_item_codes: –ú–∞—Ç–µ—Ä–∏–∞–ª '{material_code}' –Ω–µ –∏–º–µ–µ—Ç 'rarity_level'. –ò—Å–ø–æ–ª—å–∑—É–µ–º —É—Ä–æ–≤–µ–Ω—å —Ä–µ–¥–∫–æ—Å—Ç–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: {DEFAULT_RARITY_LEVEL}.")
                    else:
                        rarity_level_to_use = int(material_rarity_level)
                    
                    material_type = material_info.get('type')
                    if not material_type:
                        logger.warning(f"build_etalon_item_codes: –ú–∞—Ç–µ—Ä–∏–∞–ª '{material_code}' –Ω–µ –∏–º–µ–µ—Ç 'type'. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º.")
                        continue

                    is_compatible = False
                    category_rules = MATERIAL_COMPATIBILITY_RULES.get(category)
                    
                    if category_rules:
                        if material_type in category_rules.get("disallowed_types", []):
                            is_compatible = False
                        elif material_type in category_rules.get("allowed_types", []):
                            is_compatible = True
                        else:
                            is_compatible = False
                    else:
                        is_compatible = False

                    if not is_compatible:
                        logger.debug(f"build_etalon_item_codes: –ù–µ—Å–æ–≤–º–µ—Å—Ç–∏–º–∞—è –∫–æ–º–±–∏–Ω–∞—Ü–∏—è: –ü—Ä–µ–¥–º–µ—Ç '{category}' ({base_code}) –∏ –ú–∞—Ç–µ—Ä–∏–∞–ª '{material_type}' ({material_code}). –ü—Ä–æ–ø—É—Å–∫–∞–µ–º.")
                        continue

                    suffix_codes_to_check = list(suffixes_data.keys())
                    if "BASIC_EMPTY" not in suffix_codes_to_check:
                        suffix_codes_to_check.insert(0, "BASIC_EMPTY")
                    
                    if not suffix_codes_to_check:
                        logger.warning(f"build_etalon_item_codes: –ù–µ—Ç —Å—É—Ñ—Ñ–∏–∫—Å–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Å –º–∞—Ç–µ—Ä–∏–∞–ª–æ–º '{material_code}'.")
                        continue

                    for suffix_code in suffix_codes_to_check:
                        suffix_codes_processed += 1
                        suffix_info = suffixes_data.get(suffix_code)
                        
                        is_suffix_allowed = (suffix_code == "BASIC_EMPTY" or 
                                             (suffix_info and suffix_info.get('group') and suffix_info.get('group') in allowed_suffix_groups))
                        
                        if not is_suffix_allowed:
                            logger.debug(f"build_etalon_item_codes: –°—É—Ñ—Ñ–∏–∫—Å '{suffix_code}' (–≥—Ä—É–ø–ø–∞: {suffix_info.get('group') if suffix_info else 'N/A'}) –Ω–µ —Ä–∞–∑—Ä–µ—à–µ–Ω –¥–ª—è '{original_specific_name}' (—Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ: {allowed_suffix_groups}). –ü—Ä–æ–ø—É—Å–∫–∞–µ–º.")
                            continue

                        specific_name_for_code = re.sub(r'[^A-Z0-9]+', '-', original_specific_name).strip('-').upper()
                        
                        item_code = generate_item_code(
                            category=category, 
                            base_code=base_code, 
                            specific_name=specific_name_for_code,
                            material_code=material_code, 
                            suffix_code=suffix_code, 
                            rarity_level=rarity_level_to_use 
                        )
                        
                        spec_tuple = (
                            item_code, category, base_code, original_specific_name,
                            material_code, suffix_code, rarity_level_to_use
                        )
                        # –ó–∞–ø–∏—Å—å –≤ —Å–ª–æ–≤–∞—Ä—å –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–º—É item_code
                        etalon_item_data_specs[item_code] = spec_tuple

        end_time = time.time()
        elapsed_time = end_time - start_time 

        logger.info(f"build_etalon_item_codes: –ü—Ä–æ—Ü–µ—Å—Å –∑–∞–≤–µ—Ä—à–µ–Ω. –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: "
                    f"bases={base_codes_processed}, specific_names={specific_names_processed}, "
                    f"materials={material_codes_processed}, suffixes={suffix_codes_processed}.")
        logger.info(f"ItemTemplatePlannerLogic: –ü–æ—Å—Ç—Ä–æ–µ–Ω —ç—Ç–∞–ª–æ–Ω–Ω—ã–π –ø—É–ª –∏–∑ {len(etalon_item_data_specs)} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö item_code —Å–æ —Å–≤—è–∑–∞–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏. –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {elapsed_time:.2f} —Å–µ–∫—É–Ω–¥.") 
        return etalon_item_data_specs

    def find_missing_specs(self, etalon_specs: Dict[str, Tuple], existing_codes: Set[str]) -> List[Tuple]:
        # –†–∞–±–æ—Ç–∞–µ–º —Å–æ —Å–ª–æ–≤–∞—Ä–µ–º
        missing_specs = [spec for item_code, spec in etalon_specs.items() if item_code not in existing_codes]
        return missing_specs

    def prepare_tasks_for_missing_items( 
        self, missing_specs: List[Tuple], item_generation_limit: Optional[int]
    ) -> List[Dict[str, Any]]:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∑–∞–¥–∞—á –¥–ª—è –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤ —Å —É—á–µ—Ç–æ–º –ª–∏–º–∏—Ç–∞."""
        tasks_list: List[Dict[str, Any]] = []
        for item_code, category, base_code, specific_name_key, material_code, suffix_code, rarity_level in missing_specs:
            tasks_list.append({
                'item_code': item_code, 'category': category, 'base_code': base_code,
                'specific_name_key': specific_name_key, 'material_code': material_code,
                'suffix_code': suffix_code, 'rarity_level': rarity_level
            })
        if self.item_generation_limit is not None and self.item_generation_limit >= 0: 
            original_count = len(tasks_list)
            tasks_list = tasks_list[:self.item_generation_limit]
            if len(tasks_list) < original_count:
                logger.warning(f"item_template_planner_logic: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–¥–∞—á –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ –¥–æ {self.item_generation_limit} (–∏–∑–Ω–∞—á–∞–ª—å–Ω–æ {original_count}).")
        return tasks_list
